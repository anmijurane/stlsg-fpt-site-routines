---
// Importaciones de componentes y assets
import Modal from "@components/global/Modal.astro";
import Button from "@components/Button.astro";
import { Image } from "astro:assets";

// Importaciones de íconos
import emojiFrown from "@assets/icons/emoji-sad.svg";
import emojiNeutral from "@assets/icons/emoji-neutral.svg";
import emojiSmile from "@assets/icons/emoji-happy.svg";

// Se define una estructura de datos para los botones de feedback para evitar repetición en el template.
const feedbackOptions = [
  {
    feedbackType: "happy",
    label: "Buena",
    icon: emojiSmile,
    alt: "Emoji feliz",
  },
  {
    feedbackType: "neutral",
    label: "Regular",
    icon: emojiNeutral,
    alt: "Emoji neutral",
  },
  {
    feedbackType: "sad",
    label: "Mala",
    icon: emojiFrown,
    alt: "Emoji triste",
  },
];
---

<Modal id="feedback" closeBy="none">
  <div class="text-center">
    <h3 class="text-3xl font-bold text-theme-primary" id="modal-title">
      ¡TU OPINIÓN<br />NOS IMPORTA!
    </h3>
    <div class="mt-2">
      <p class="text-md text-gray-500 font-semibold">
        En esta primera etapa nos gustaría saber como ha sido tu experiencia
      </p>
    </div>
  </div>

  <div
    id="feedback-container"
    class="mt-8 flex flex-col items-center justify-center gap-6"
  >
    {
      feedbackOptions.map(({ feedbackType, label, icon, alt }) => (
        <Button
          variant="transparent"
          data-feedback={feedbackType}
          class="flex cursor-pointer justify-center items-center text-start w-full"
        >
          <div class="w-2/3 flex justify-end">
            <Image src={icon} alt={alt} />
          </div>
          <span class="mt-1 ml-1 w-1/2 font-semibold text-theme-primary">
            {label}
          </span>
        </Button>
      ))
    }

    <div
      class="flex-col gap-6 items-center hidden w-full"
      id="comment_feedback"
    >
      <span class="text-base text-gray-500 font-semibold"
        >Cuéntanos tu experiencia</span
      >
      <textarea
        name="comment"
        id="comment"
        class="resize-none w-full h-52 border border-theme-primary rounded-md active:border-2 focus:border-2 focus:border-theme-primary p-4 text-xs"
      ></textarea>
      <span id="error" class="text-red-500 text-sm w-full text-start opacity-0">
        Escribe un texto valido, sin empezar con espacios ni usar solo símbolos.
      </span>
      <Button variant="primary" id="sendComment" class="w-4/6"> Enviar </Button>
    </div>
  </div>
</Modal>

<script>
  import { actions } from "astro:actions";
  import type { Emoji } from "@interfaces/common";

  const sanitizeRegExp =
    /(?:\r\n|\r|\n)+|<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>|<[^>]*>/gi;
  const regExpText: RegExp =
    /^(?=.*\p{L}{2})[\p{L}\p{M}\d\s.,;:¡!¿?\-()"'/%+@#&]+$/u;

  // --- ESTADO GLOBAL Y CONTROLADORES ---
  const session = {
    state: {
      modalHasBeenShown: false,
      screenTimeSeconds: 0,
      clicks: 0,
    },
    intervalId: null as NodeJS.Timeout | null,
    // Controlador para limpiar listeners al cambiar de página
    pageUnloadController: null as AbortController | null,
  };

  const loadState = () => {
    const storedState = sessionStorage.getItem("_feedbackState");
    if (storedState) {
      session.state = { ...session.state, ...JSON.parse(storedState) };
    }
  };

  const saveState = () => {
    sessionStorage.setItem("_feedbackState", JSON.stringify(session.state));
  };

  const initializeFeedbackSystem = () => {
    loadState();
    session.pageUnloadController = new AbortController();
    const pageSignal = session.pageUnloadController.signal;

    if (sessionStorage.getItem("_feedback") || session.state.modalHasBeenShown)
      return;

    // Controlador específico para los listeners que activan el modal
    const triggerController = new AbortController();
    const triggerSignal = triggerController.signal;

    const feedbackContainer = document.getElementById("feedback-container");
    const commentFeedbackContent = document.getElementById("comment_feedback");
    const sendCommentButton = document.getElementById("sendComment");
    const commentTextarea =
      document.querySelector<HTMLTextAreaElement>("#comment");
    const errorSpan = document.querySelector<HTMLSpanElement>("#error");

    const sendInitialFeedback = async (type: Emoji) => {
      if (sessionStorage.getItem("_feedback")) return;
      try {
        const result = await actions.CreateFeedback({
          emoji: type,
          comment: "N/A",
          page_path: document.location.pathname,
          rejected: type === "closed",
        });
        if (result.data?.id) {
          sessionStorage.setItem("_feedback", result.data.id);
        }
      } catch (error) {
        console.error("Error al crear el feedback:", error);
      }
    };

    const sendFeedbackComment = async (event: MouseEvent) => {
      event.stopPropagation();
      const feedbackId = sessionStorage.getItem("_feedback");
      if (!feedbackId) {
        closeModal();
        return;
      }
      if (!commentTextarea) return;
      const valueComment = commentTextarea.value.trim();
      const isValidText = regExpText.test(valueComment);
      if (valueComment.length > 0 && isValidText) {
        errorSpan?.classList.add("opacity-0");
        try {
          const sanitizeText = valueComment
            .replace(sanitizeRegExp, " ")
            .trim()
            .replace(/\s{2,}/g, " ");
          await actions.UpdateCommentFeedback({
            id: feedbackId,
            comment: sanitizeText,
          });
          closeModal();
        } catch (error) {
          console.error("Error al actualizar el comentario:", error);
        }
      } else {
        errorSpan?.classList.remove("opacity-0");
      }
    };

    const closeModal = () => {
      const modalDialog = document.getElementById("feedback") as HTMLDivElement;
      const panel = modalDialog?.querySelector("[data-panel]");
      if (!modalDialog || !panel) return;
      panel.classList.add("closing");
      setTimeout(() => {
        modalDialog.classList.add("hidden");
        panel.classList.remove("open");
        panel.classList.remove("closing");
        document.body.style.overflow = "";
      }, 250);
      document.dispatchEvent(new Event("close-modal-feedback"));
    };

    const considerOpeningModal = () => {
      const MIN_CLICKS = 15; // OLD 30
      const MAX_CLICKS = 25; // OLD 45
      const TIME_IN_SECONDS_TO_SHOW = 180; // 3 min OLD 300

      const randomClickTarget =
        Math.floor(Math.random() * (MAX_CLICKS - MIN_CLICKS + 1)) + MIN_CLICKS;

      const hasEnoughClicks = session.state.clicks >= randomClickTarget;
      const hasEnoughTime =
        session.state.screenTimeSeconds > TIME_IN_SECONDS_TO_SHOW;

      if (
        (hasEnoughClicks || hasEnoughTime) &&
        !session.state.modalHasBeenShown
      ) {
        session.state.modalHasBeenShown = true;
        saveState();

        const modalDialog = document.getElementById(
          "feedback",
        ) as HTMLDivElement | null;
        const panel = modalDialog?.querySelector("[data-panel]");
        if (!modalDialog || !panel) return;
        setTimeout(() => {
          panel?.classList.add("open");
          modalDialog?.classList.remove("hidden");
          document.body.style.overflow = "hidden";
        }, 0);

        triggerController.abort();
        if (session.intervalId) clearInterval(session.intervalId);
      }
    };

    const handleFeedbackButtonClick = (event: MouseEvent) => {
      // Se detiene la propagación para que el clic no se cuente como un "clic global".
      event.stopPropagation();

      const button = (event.target as HTMLElement).closest<HTMLButtonElement>(
        "button[data-feedback]",
      );
      if (!button) return;

      const feedbackType = (button.dataset.feedback || "closed") as Emoji;
      sendInitialFeedback(feedbackType);

      const allFeedbackButtons =
        feedbackContainer?.querySelectorAll<HTMLButtonElement>(
          "button[data-feedback]",
        );
      allFeedbackButtons?.forEach((btn) => {
        if (btn !== button) btn.style.display = "none";
        btn.setAttribute("disabled", "true");
      });
      commentFeedbackContent?.classList.replace("hidden", "flex");
    };

    const handleCloseButtonClick = () => {
      sendInitialFeedback("closed");
      document.dispatchEvent(new Event("close-modal-feedback"));
    };

    const handleGlobalClick = () => {
      session.state.clicks++;
      saveState();
      considerOpeningModal();
    };

    // Listeners que activan el modal (usan triggerSignal)
    document.body.addEventListener("click", handleGlobalClick, {
      signal: triggerSignal,
    });

    // Listeners de interacción del modal (usan pageSignal)
    feedbackContainer?.addEventListener("click", handleFeedbackButtonClick, {
      signal: pageSignal,
    });
    // buttonClose?.addEventListener("click", handleCloseButtonClick, {
    //   signal: pageSignal,
    // });
    sendCommentButton?.addEventListener("click", sendFeedbackComment, {
      signal: pageSignal,
    });

    session.intervalId = setInterval(() => {
      session.state.screenTimeSeconds++;
      saveState();
      considerOpeningModal();
    }, 1000);
  };

  document.addEventListener("astro:page-load", initializeFeedbackSystem);

  document.addEventListener("astro:before-swap", () => {
    // Se aborta el controlador principal para limpiar los listeners del modal
    session.pageUnloadController?.abort();
    // Y se limpia el intervalo por si acaso
    if (session.intervalId) {
      clearInterval(session.intervalId);
    }
  });
</script>
